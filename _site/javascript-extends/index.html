<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.5.0 --> <title>자바스크립트 상속. | Dolen’s blog</title> <meta name="generator" content="Jekyll v3.8.5" /> <meta property="og:title" content="자바스크립트 상속." /> <meta property="og:locale" content="en_US" /> <meta name="description" content="자바스크립트의 상속을 정리해보겠습니다." /> <meta property="og:description" content="자바스크립트의 상속을 정리해보겠습니다." /> <link rel="canonical" href="http://localhost:4000/javascript-extends/" /> <meta property="og:url" content="http://localhost:4000/javascript-extends/" /> <meta property="og:site_name" content="Dolen’s blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2016-10-02T05:00:00+09:00" /> <script type="application/ld+json"> {"description":"자바스크립트의 상속을 정리해보겠습니다.","@type":"BlogPosting","url":"http://localhost:4000/javascript-extends/","headline":"자바스크립트 상속.","dateModified":"2016-10-02T05:00:00+09:00","datePublished":"2016-10-02T05:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/javascript-extends/"},"@context":"http://schema.org"}</script> <!-- End Jekyll SEO tag --> <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> --> <link rel="stylesheet" href="/css/main.css"> <link rel="alternate" type="application/rss+xml" title="Dolen's blog" href="http://localhost:4000/feed.xml"> <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> </head> <body> <header class="site-header"> <nav class="navbar navbar-default"> <div class="container-fluid"> <!-- Brand and toggle get grouped for better mobile display --> <div class="navbar-header"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Dolen's blog</a> </div> <!-- Collect the nav links, forms, and other content for toggling --> <div class="collapse navbar-collapse " id="bs-example-navbar-collapse-1"> <ul class="nav navbar-nav navbar-right"> <li><a href="/about/">About</a></li> <li><a href="/contact/">Contact</a></li> </ul> </div><!-- /.navbar-collapse --> </div><!-- /.container-fluid --> </nav> </header> <div class="container"> <div class="wrapper"> <div class="row"> <div class="col-md-8"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title" itemprop="name headline">자바스크립트 상속.</h1> <p class="post-meta"><time datetime="2016-10-02T05:00:00+09:00" itemprop="datePublished">Oct 2, 2016</time></p> </header> <div class="post-content" itemprop="articleBody"> <p><code class="highlighter-rouge">자바스크립트의 상속</code>을 정리해보겠습니다.</p> <p>예전에 정리해두었던건데, 영 마구잡이식이어서 블로그도 새로 만들었고 되새김질도 하는 김에 정리해봅니다.</p> <p>시작해볼까요 :)</p> <h3 id="기본적인-상속">기본적인 상속</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parent</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>

<span class="nx">c</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Test'</span><span class="p">;</span>


<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//Test</span>

<span class="k">delete</span> <span class="nx">c</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="c1">//ok.</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//Parent</span>
</code></pre></div></div> <p>실행 결과를 보게되면 Child 함수에는 자신의 프로토타입 프로퍼티를 가리키는 <strong>proto</strong> 변수외에는 아무것도 없습니다.</p> <p><strong>proto__를 열어보게되면 c.__proto</strong> -&gt; 안에는 Parent.__proto__에 할당되어있는 값이 할당되는데 그 값은 다음과 같습니다.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
 <span class="nl">name</span> <span class="p">:</span> <span class="s1">'Parent'</span><span class="p">,</span>
 <span class="nx">__proto__</span> <span class="p">:</span> <span class="p">{</span>
     <span class="nl">constructor</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
     <span class="p">},</span>
     <span class="nx">say</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
     <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>그렇기 때문에 기본적으로 c.name을 검색했을때에는 연쇄적인 체이닝 검색이 일어나게 되는거지요.</p> <p>이 패턴의 방식은 this로 지정된 Child함수에서 매번 name값을 찾으려면 c.<strong>proto</strong>.name 을 찾게 되고</p> <p>c.say() 를 하려 한다면, c.<strong>proto</strong>.<strong>proto</strong>.say(); 를 하게 된다는 점입니다.</p> <p>만약 say()를 못 찾게 되면 최상단 오브젝트까지 가서 찾게 되는 거지요.</p> <p>또한 c.name 을 하게 되면 name 객체 자체 오브젝트에 값이 할당되므로, name = Test로 할당되지만, 그 객체값이 사라지게 되면,</p> <p>다시 <strong>proto</strong> 값을 참조하게 되며 결국은 부모객체중의 name 값을 가져오게 됩니다.</p> <p>그리고 또 한가지 위험한 단점이 존재하게 되는데요.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parent</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>


<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>

<span class="nx">c</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">arr</span><span class="p">);</span> <span class="c1">// 두개가 같은것을 바라보게 된다.</span>
</code></pre></div></div> <p>결국 Prototype Chaning을 사용한 상속은 단순히 부모가 가지고있는 값을 참조할 수 있다는 점에서 굉장한 위험을 동반할 수 있게 됩니다.</p> <p>하나의 부모객체가 인스턴스화 된 후, 해당 객체가 여러개의 자식객체에게 상속을 해 주었고 여러개의 자식객체가 하나의 부모객체의 값을 참조하게 된다면 그 이슈는 어마어마하게 되겠죠.</p> <h3 id="생성자-빌려쓰기의-다중상속">생성자 빌려쓰기의 다중상속</h3> <p>위에서 언급했듯이, 부모 객체를 자식의 프로토타입에 덮어씌우는 상속은 꽤나 많은 문제점을 일으킬 수 있습니다.</p> <p>그래서 다른 방법을 찾게 된것이 바로 생성자 빌려쓰기 입니다.</p> <p>자바스크립트의 함수는 생성자 함수로 동작하게 될때 여러가지 재미있는 행동을 하게 되는데요.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">test</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">test</span><span class="p">);</span> <span class="c1">//3</span>
</code></pre></div></div> <p>이게 가능한 이유는 실제 자바스크립트는 이렇게 동작하기 때문입니다.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="k">this</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">//보이지는 않지만 this를 생성한 후 undefined를 할당한다.</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">test</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="c1">//return 되는 값이 없다면 암묵적으로 this를 리턴한다.</span>
<span class="p">}</span>
</code></pre></div></div> <p>이걸 이용한다면 우리는 재미있는 동작을 하게 만들 수 있게 되요 !</p> <p>함수를 생성자로서만 동작하게 만드는 것이지요.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>


<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="s1">'Child Name'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</code></pre></div></div> <p>이렇게 함으로써 자식객체는 Parent를 단순히 함수로 사용하게 되는 것이기 때문에 참조에 의한 생성이 이루어지지 않게 되요 :)</p> <p>물론, 부모의 prototype에 선언되어있는 프로퍼티와는 전혀 상관없이 부모의 참조 변수값만 할당 받는 방식이기 때문에 경우에 따라서 잘 사용해야 하겠지요.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Parent2</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent2'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">brr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
    <span class="nx">Parent2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>


<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="s1">'Child Name'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//Child Name</span>
</code></pre></div></div> <p>또한 이런 식의 다중상속또한 가능하게 됩니다.</p> <p>그런데 이건 완전한 상속이 아니게 됩니다. 부모의 say 함수는 상속받지 못하였거든요..</p> <p>그러면 부모의 함수마저도 상속받으려면 어떻게 하면 좋을까요 ??</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Parent2</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent2'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">brr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
    <span class="nx">Parent2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parent</span><span class="p">();</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parent2</span><span class="p">();</span>
</code></pre></div></div> <p>이처럼 하게 되면, 자식은 자신만의 변수를 할당하게 되고, 참조 또한 모든 참조를 하게 됩니다.</p> <p>하지만 생성자에서 한번, 프로토타입에서 한번 총 2번의 부모 생성자를 호출하게 되는 불편함이 존재하며 결국 부모를 생성하여 프로토타입을 가져오게 되어</p> <p>애초에 문제를 재기하였던 프로토타입 체이닝이 이어지게 됩니다.</p> <p>그렇다면, 부모생성자를 호출하지 않고도 사용하는 방법이란 이런것도 있지 않을까요 ?</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Parent2</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent2'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">brr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent2</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="nx">Parent2</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
    <span class="nx">Parent2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>


<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Parent2</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

</code></pre></div></div> <p>하지만, 이렇게 하면 모든 프로토타입은 공유될 수 있을지 모르나 다중 프로토타입을 구현하려면 굉장히 복잡하게 될 뿐더러</p> <p>모두가 하나의 프로토타입만 바라보게 되기 때문에 위험해집니다.</p> <p>어느 한군데에서 변경하게 되면 전부 망가질 가능성이 있기 때문이죠 T ^T.</p> <h3 id="proxy-타입의-완벽한-상속">Proxy 타입의 완벽한 상속</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'say'</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'생성대따아!!'</span><span class="p">);</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nb">Proxy</span><span class="p">()</span> <span class="p">{};</span>

<span class="nb">Proxy</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">();</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Child</span><span class="p">;</span>

<span class="nb">Proxy</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
</code></pre></div></div> <p>자 어떤가요 ? 이해가 가셨나요 ?</p> <ol> <li>Proxy 함수에 부모의 prototype을 복제합니다.</li> <li>자식에게 Proxy의 프h로토타입을 상속해 줍니다.</li> <li>자식의 생성자 함수를 Child함수로 지정해 줍니다.</li> <li>Proxy 의 prototype을 삭제함으로 체인을 끊어 줍니다. (이미 new Proxy()가 되어 메모리에 올라가 있으므로 자식의 prototype은 전혀 지장을 받지 않습니다.)</li> <li>자식을 인스턴스화합니다. (말 그대로 완벽한 상속이 이루어졌습니다.)</li> </ol> <p>자 이제 이걸 함수화 시켜볼까요 ??</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">'Parent'</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'say'</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'생성돼떠!'</span><span class="p">);</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>


<span class="kd">var</span> <span class="nx">inherit</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nb">Proxy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">Parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">Proxy</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
        <span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">();</span>
        <span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Child</span><span class="p">;</span>
        <span class="nb">Proxy</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}());</span>


<span class="nx">inherit</span><span class="p">(</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">Parent</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
</code></pre></div></div> <p>Child는 부모의 변수값만 복사해왔고, constructor는 자식의 값으로 지정되어 있으며 <strong>proto</strong> 의 값을 확인해보면 Proxy가 물려준 부모의 prototype이 입력되어 있습니다.</p> <p>이상 상속의 정리를 마칩니다.</p> <p>ES6의 CLASS에 대해서 아주 잘 정리된 곳이 있으니 공유합니다. :)</p> <p><a href="https://gomugom.github.io/es6/2016/10/04/is-class-only-a-syntactic-sugar">고무곰님의 ES6의 CLASS에 대하여</a></p> </div> </article> <div class="row"> <div id="disqus_thread"></div> <script defer> (function() { var d = document, s = d.createElement('script'); s.src = '//dolen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> <div class="row"> <ul class="pager"> <li><a class="next" href="/javascript-pattern/">&laquo; 자바스크립트 디자인 패턴.</a></li> <li><a class="previous" href="/java-separator/">JAVA 가변인자와 ENUM &raquo;</a></li> </ul> </div> </div> <div class="col-md-4 mt20"> <div class="post-img"> <img width="600" src="/images/javascript.jpg" alt="자바스크립트 상속."> </div> <div class="mt10 recent"> <h4>Previous post</h4> <div> <p><a href="/java-separator/">JAVA 가변인자와 ENUM</a> <small>&nbsp;&nbsp;01 Oct 2016</small> </p> </div> <h4>Next post</h4> <div> <p><a href="/javascript-pattern/">자바스크립트 디자인 패턴.</a> <small>&nbsp;&nbsp;03 Oct 2016</small> </p> </div> </div> <br> </div> </div> </div> </div> <footer> <div class="container"> <div class="row p20"> <div class="col-md-4 text-center mt25" > </div> <div class="col-md-4 text-center mt25"> <a target="_blank" href="https://www.facebook.com/taesan.choi"><li class="social facebook"><i class="fa fa-facebook-square"></i></li></a> <a target="_blank" href="http://github.com/imcts"><li class="social github"><i class="fa fa-github-square"></i></li></a> <a target="_blank" href="mailto:imcts@nate.com"><li class="social email"><i class="fa fa-envelope"></i></li></a> </div> </div> </div> </footer> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script> <script src="/js/bootstrap.min.js"></script> <!-- Google Analytics Tracking code --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-83979019-1', 'auto'); ga('send', 'pageview'); </script> </body> </html>
