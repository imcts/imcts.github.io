<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.5.0 --> <title>ES6 - THE NEW METHODS OF STRING AND ARRAY | Dolen’s blog</title> <meta name="generator" content="Jekyll v3.8.5" /> <meta property="og:title" content="ES6 - THE NEW METHODS OF STRING AND ARRAY" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="String ES6의 String에는 몇 가지 메소드가 추가 되었습니다. 기존 메소드에 비해 새로운 메소드들의 실행 결과값은 의도를 쉽게 파악할 수 있도록 구현 되었습니다." /> <meta property="og:description" content="String ES6의 String에는 몇 가지 메소드가 추가 되었습니다. 기존 메소드에 비해 새로운 메소드들의 실행 결과값은 의도를 쉽게 파악할 수 있도록 구현 되었습니다." /> <link rel="canonical" href="http://localhost:4000/ES6-STRING-ARRAY-METHODS/" /> <meta property="og:url" content="http://localhost:4000/ES6-STRING-ARRAY-METHODS/" /> <meta property="og:site_name" content="Dolen’s blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-01-21T09:00:00+09:00" /> <script type="application/ld+json"> {"description":"String ES6의 String에는 몇 가지 메소드가 추가 되었습니다. 기존 메소드에 비해 새로운 메소드들의 실행 결과값은 의도를 쉽게 파악할 수 있도록 구현 되었습니다.","@type":"BlogPosting","url":"http://localhost:4000/ES6-STRING-ARRAY-METHODS/","headline":"ES6 - THE NEW METHODS OF STRING AND ARRAY","dateModified":"2019-01-21T09:00:00+09:00","datePublished":"2019-01-21T09:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/ES6-STRING-ARRAY-METHODS/"},"@context":"http://schema.org"}</script> <!-- End Jekyll SEO tag --> <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> --> <link rel="stylesheet" href="/css/main.css"> <link rel="alternate" type="application/rss+xml" title="Dolen's blog" href="http://localhost:4000/feed.xml"> <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> </head> <body> <header class="site-header"> <nav class="navbar navbar-default"> <div class="container-fluid"> <!-- Brand and toggle get grouped for better mobile display --> <div class="navbar-header"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Dolen's blog</a> </div> <!-- Collect the nav links, forms, and other content for toggling --> <div class="collapse navbar-collapse " id="bs-example-navbar-collapse-1"> <ul class="nav navbar-nav navbar-right"> <li><a href="/about/">About</a></li> <li><a href="/contact/">Contact</a></li> </ul> </div><!-- /.navbar-collapse --> </div><!-- /.container-fluid --> </nav> </header> <div id="container" class="container"> <div class="wrapper"> <div class="row" style="position: relative;"> <div class="col-md-8"> <article id="post" class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title" itemprop="name headline">ES6 - THE NEW METHODS OF STRING AND ARRAY</h1> <p class="post-meta"><time datetime="2019-01-21T09:00:00+09:00" itemprop="datePublished">Jan 21, 2019</time></p> </header> <div class="post-content" itemprop="articleBody"> <h2 id="string">String</h2> <p><code class="highlighter-rouge">ES6</code>의 <code class="highlighter-rouge">String</code>에는 몇 가지 메소드가 추가 되었습니다. 기존 메소드에 비해 새로운 메소드들의 실행 결과값은 의도를 쉽게 파악할 수 있도록 구현 되었습니다.</p> <h4 id="includes-startswith-endswith">includes, startsWith, endsWith</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">'str'</span>

<span class="c1">// ES5</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'s'</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span>              <span class="c1">// true</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'r'</span><span class="p">)</span> <span class="o">===</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// true</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'tt'</span><span class="p">)</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span>            <span class="c1">// true</span>

<span class="c1">// ES6</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">'s'</span><span class="p">)</span>   <span class="c1">// true</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s1">'str'</span><span class="p">)</span> <span class="c1">// true</span>

<span class="nx">str</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s1">'r'</span><span class="p">)</span>     <span class="c1">// true</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s1">'tr'</span><span class="p">)</span>    <span class="c1">// true</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>      <span class="c1">// true</span>

<span class="nx">str</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">'tt'</span><span class="p">)</span>    <span class="c1">// false</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES5</code>까지는 <code class="highlighter-rouge">indexOf</code>메소드를 활용하여, 문자열 안에 문자를 찾고 해당 문자의 <code class="highlighter-rouge">index</code>를 반환받아 결과를 판단해야만 했습니다. <code class="highlighter-rouge">indexOf</code>메소드는 인자로 전달한 문자가 문자열에 포함되어 있으면 해당 <code class="highlighter-rouge">index</code>값을 반환하고 포함되어 있지 않는 경우에는 <code class="highlighter-rouge">-1</code>을 반환합니다. 이 결과값들은 여러가지 혼란스러운 점을 제공할 수 있는데요. 기존에 자바스크립트를 접하고 사용하던 개발자들이라면 크게 문제될 것 없이 해당 메소드를 사용할 수 있지만 자바스크립트에 익숙하지 않은 개발자들의 경우에는 해당 반환값이 어떤 의미를 갖는지 알기 어렵습니다. <code class="highlighter-rouge">-1</code>이라는 값은 자바스크립트에서는 <code class="highlighter-rouge">trusy</code>이기 때문입니다. <br /><br /> <code class="highlighter-rouge">ES6</code>에서는 문자열 메소드에 새로운 <code class="highlighter-rouge">startsWith</code>, <code class="highlighter-rouge">endsWith</code>, <code class="highlighter-rouge">includes</code>메소드들을 제공하며 <code class="highlighter-rouge">Boolean</code>값을 반환하도록 하고 있습니다. 새로 추가된 메소드들을 사용하면 좀 더 명확하게 코드에 의도를 나타낼 수 있을 뿐더러 반환되는 <code class="highlighter-rouge">Boolean</code>값을 사용하여 결과를 판단하기도 수월해 졌습니다.</p> <h4 id="iteration">iteration</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">'str'</span>

<span class="c1">// ES5</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// s, t, r </span>
<span class="p">}</span>

<span class="c1">// ES6</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">c</span> <span class="k">of</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// s, t, r</span>
<span class="p">}</span>

<span class="p">[...</span><span class="nx">str</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">)</span> <span class="c1">// s, t, r</span>
</code></pre></div></div> <p>자바스크립트의 문자열은 내부적으로 <code class="highlighter-rouge">length</code>프로퍼티를 갖고 각 문자열마다 <code class="highlighter-rouge">index</code>를 갖게 됩니다. 그렇기 때문에 <code class="highlighter-rouge">ES5</code>까지는 문자의 <code class="highlighter-rouge">index</code>를 참조하여 각 문자를 순회하는 방식의 코드를 작성했었습니다. <code class="highlighter-rouge">ES6</code>에서 자바스크립트의 문자열은 <code class="highlighter-rouge">Iterable</code>이기 때문에 <code class="highlighter-rouge">for..of</code>구문을 사용할 수 있고 <code class="highlighter-rouge">Destrucuring</code>또한 가능하기 때문에 <code class="highlighter-rouge">Spread</code>연산자도 사용할 수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="s1">''</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="o">+=</span> <span class="s1">'s'</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="c1">// sssss</span>

<span class="c1">// ES6</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'s'</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="c1">// sssss</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES5</code>에서는 문자열을 반복해서 더하려면 꽤나 복잡한 코드를 작성해야만 했습니다. 문자를 합성한 결과를 매번 저장할 변수를 선언해야 하고 반복문을 사용하여 문자를 원하는 횟수만큼 더해주어야 했습니다. 이처럼 반복적으로 작성해야 하는 코드들은 복사되어 여러군데에 생성되기 쉬웠고 사소한 실수로 인해 프로그램이 망가지기도 했습니다. <code class="highlighter-rouge">ES6</code>에서는 문자열을 반복하여 더해주는 메소드를 언어 차원에서 제공합니다. <code class="highlighter-rouge">String.repeat</code>을 사용하면 원하는 문자열을 원하는 만큼 반복시킬 수 있습니다.</p> <h4 id="padstart-padend">padStart, padEnd</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">'123'</span>

<span class="nx">str</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">//        123</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>   <span class="c1">// 123      </span>

<span class="nx">str</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">'*'</span><span class="p">)</span> <span class="c1">// **123</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">'*'</span><span class="p">)</span>   <span class="c1">// 123**</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES7</code>에서는 <code class="highlighter-rouge">padStart</code>, <code class="highlighter-rouge">padEnd</code>메소드가 추가 되었습니다. 인자는 2개의 값을 전달받으며 첫 번째 인자는 <code class="highlighter-rouge">maxLength</code>이고 두 번째 인자는 채워줄 값이 됩니다. 두 번째 인자를 전달하지 않았을 경우에는 공백 문자가 기본값이 됩니다. <br /> <br /> <br /></p> <h2 id="array">Array</h2> <p><code class="highlighter-rouge">ES6</code>에는 <code class="highlighter-rouge">Array</code>객체에도 메소드들이 추가 되었습니다.</p> <h4 id="from">from</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">'str'</span>

<span class="c1">// ES5</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

<span class="c1">// ES6</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="c1">// ['s', 't', 'r']</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// ['ss', 'tt', 'rr']</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES5</code>까지는 <code class="highlighter-rouge">slice</code>메소드에 인자를 전달하지 않으면 새로운 배열을 생성하여 반환하는 점을 이용해 <code class="highlighter-rouge">유사배열</code>을 전달하여 진짜 배열 객체를 생성하고는 했습니다. <code class="highlighter-rouge">ES6</code>에서 추가된 <code class="highlighter-rouge">from</code>메소드는 배열의 형태를 갖거나 <code class="highlighter-rouge">Iterable</code>객체를 전달받아 얕은 복사를 수행한 새로운 <code class="highlighter-rouge">Array</code>객체를 반환 합니다. 인자로는 3가지를 전달 받으며 첫 번째인자는 순회가능한 객체이고 두 번째로는 해당 객체가 배열로 반환되기 전에 실행될 <code class="highlighter-rouge">map</code>함수 이며 마지막 인자로는 <code class="highlighter-rouge">this</code>를 바인딩할 객체입니다.</p> <h4 id="of">of</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// [4]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>

<span class="nb">Array</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// [, , , ,]</span>
<span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Array</code>생성자는 여러개의 인자를 전달할 경우 배열을 생성하여 반환하지만 하나의 값만 전달하는 경우에는 비어있는 배열을 생성하여 반환합니다. <code class="highlighter-rouge">Array.of</code>메소드는 생성자와는 다르게 전달된 인자를 <code class="highlighter-rouge">값</code>으로 갖는 새로운 배열을 반환 합니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
<span class="kd">const</span> <span class="nx">brr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>         <span class="c1">// [1, 2, 3]</span>
<span class="kd">const</span> <span class="nx">crr</span> <span class="o">=</span> <span class="p">[...</span><span class="s1">'123'</span><span class="p">]</span>        <span class="c1">// ['1', '2', '3']</span>
</code></pre></div></div> <p>그렇다면 배열 리터럴을 사용하는 것과 <code class="highlighter-rouge">Array.of</code>를 사용하는 것에 무슨 차이가 있을까요.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Class</span> <span class="o">=</span> <span class="kd">class</span> <span class="kd">extends</span> <span class="nb">Array</span> <span class="p">{}</span>
<span class="nx">Class</span><span class="p">.</span><span class="k">from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">instanceof</span> <span class="nx">Class</span> <span class="c1">// true</span>
<span class="nx">Class</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">instanceof</span> <span class="nx">Class</span>                 <span class="c1">// true</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES6</code>에서는 자바스크립트의 내장객체를 <code class="highlighter-rouge">prototype</code>이 아닌 <code class="highlighter-rouge">HomeObject</code>를 사용하여 상속받을 수 있습니다. <code class="highlighter-rouge">Array.of</code>메소드와 <code class="highlighter-rouge">Array.from</code>메소드를 활용하면 특정 <code class="highlighter-rouge">class</code>의 인스턴스로서 배열을 생성할 수 있습니다. <code class="highlighter-rouge">Array.form</code>의 경우에는 생성 시 사용할 <code class="highlighter-rouge">map</code>함수도 같이 전달할 수 있게 되어 유사배열로 특정 인스턴스를 생성할때 유용하게 사용할 수도 있습니다.</p> <h4 id="find">find</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 3</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nx">find</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">===</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// undefined</span>
</code></pre></div></div> <p><code class="highlighter-rouge">ES5</code>까지는 배열에 있는 값을 찾기 위해서는 <code class="highlighter-rouge">반복문</code>으로 순회하며 해당 값을 찾으면 반환하는 로직을 매번 작성하였습니다. <code class="highlighter-rouge">Array.find</code>를 사용하면 인자에 전달된 <code class="highlighter-rouge">predicate</code>함수에서 <code class="highlighter-rouge">truthy</code>를 반환하는 요소 중 첫번째 요소를 반환 합니다.</p> <h4 id="findindex">findIndex</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">===</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// -1</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Array.findIndex</code>는 인자로 전달된 <code class="highlighter-rouge">predicate</code>함수에서 <code class="highlighter-rouge">truthy</code>를 반환하는 첫번째 값의 인덱스값을 반환 합니다. 만약 일치하는 값이 없는 경우에는 <code class="highlighter-rouge">-1</code>을 반환 합니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kc">NaN</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span> <span class="c1">// -1</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="kc">NaN</span><span class="p">).</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 0</span>
</code></pre></div></div> <p>얼핏 보면 <code class="highlighter-rouge">Array.findIndex</code>는 <code class="highlighter-rouge">Array.indexOf</code>와 동일한 기능을 하는 것 처럼 보이지만 사실은 다릅니다. 인자로 <code class="highlighter-rouge">predicate</code>함수를 전달받기 때문입니다. 자바스크립트의 <code class="highlighter-rouge">NaN</code>은 <code class="highlighter-rouge">Not a Number</code>로서 <code class="highlighter-rouge">이항연산</code>을 수행하는경우 <code class="highlighter-rouge">좌항</code>이나 <code class="highlighter-rouge">우항</code>에 <code class="highlighter-rouge">NaN</code>이 들어오면 무조건 <code class="highlighter-rouge">false</code>를 반환하도록 구현되어 있습니다. 그렇기 때문에 인자를 전달받아서 동작하는 <code class="highlighter-rouge">Array.indexOf</code>로는 <code class="highlighter-rouge">NaN</code>을 찾을 수 없었습니다. <code class="highlighter-rouge">ES6</code>에 도입된 <code class="highlighter-rouge">Number.isNaN</code>함수와 <code class="highlighter-rouge">Array.findIndex</code>를 사용하여 <code class="highlighter-rouge">NaN</code>을 찾을 수 있게 되었습니다.</p> <h4 id="fill">fill</h4> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)</span> <span class="c1">// ["*", "*", "*", "*", "*"]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)</span> <span class="c1">// ["*", "*", "*", "*", "*"]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// ["*", "*", "*", "*", 5]</span>
</code></pre></div></div> <p><code class="highlighter-rouge">Array.fill</code>은 배열의 값을 인자로 주어진 값으로 모두 대체 합니다. 1개의 인자만 전달하게 되면 해당 값으로 배열을 채우게 되지만 <code class="highlighter-rouge">startIndex</code>와 <code class="highlighter-rouge">endIndex</code>를 전달하게 되면 어디서부터 어디까지 채울 것인지를 지정할 수 있게 됩니다.</p> </div> </article> <div class="row"> <div id="disqus_thread"></div> <script defer> (function() { var d = document, s = d.createElement('script'); s.src = '//dolen.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> <div class="row"> <ul class="pager"> <li><a class="next" href="/NODE-DEBUGGER/">&laquo; Debugging Node.js.</a></li> <li><a class="previous" href="/ES6-CLASS-METHOD/">ES6 - CLASS &raquo;</a></li> </ul> </div> </div> <div id="post-navigator" class="col-md-4 mt20"> <div class="post-img"> <img width="600" src="/images/javascript.jpg" alt="ES6 - THE NEW METHODS OF STRING AND ARRAY"> </div> <div class="mt10 recent"> <h4>Previous post</h4> <div> <p><a href="/ES6-CLASS-METHOD/">ES6 - CLASS</a> <small>&nbsp;&nbsp;07 Jan 2019</small> </p> </div> <h4>Next post</h4> <div> <p><a href="/NODE-DEBUGGER/">Debugging Node.js.</a> <small>&nbsp;&nbsp;25 Jan 2019</small> </p> </div> </div> <br> </div> <script> var MIN_WIDTH_OF_PC_VERSION = 992; var POST_SIDE_BAR_HEIGHT = 87; var POST_SIDE_BAR_PADDING_LEFT = 15; var POST_SIDE_BAR_MARGIN_TOP = 20; var CONTAINER_PADDING_LEFT = 20; var container = document.getElementById('container'); var post = document.getElementById('post'); var postNavigator = document.getElementById('post-navigator'); var postNavigatorWidth = postNavigator.offsetWidth; var postWidth = post.offsetWidth; var postMarginLeft = +window.getComputedStyle(container)['margin-left'].split('px')[0]; /** for getting scroll position Y **/ var supportPageOffset = window.pageXOffset !== undefined; var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat"); function setSidebarStyle (position, top, left, width) { Object.assign(postNavigator.style, { position: position, top: top, left: left, width: width }) } function onScroll () { var position = ''; var top = ''; var left = ''; var width = '33.33333333%'; if (document.body.offsetWidth < MIN_WIDTH_OF_PC_VERSION) { width = ''; } else { var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop; if (y >= POST_SIDE_BAR_HEIGHT) { position = 'fixed'; top = POST_SIDE_BAR_MARGIN_TOP + 'px'; left = (postMarginLeft + postWidth + CONTAINER_PADDING_LEFT + POST_SIDE_BAR_PADDING_LEFT) + 'px'; width = postNavigatorWidth + 'px'; } } setSidebarStyle(position, top, left, width); } window.addEventListener('scroll', onScroll); window.addEventListener('resize', function () { postNavigatorWidth = postNavigator.offsetWidth; postWidth = post.offsetWidth; postMarginLeft = +window.getComputedStyle(container)['margin-left'].split('px')[0]; onScroll(); }); </script> </div> </div> </div> <footer> <div class="container"> <div class="row p20"> <div class="col-md-4 text-center mt25" > </div> <div class="col-md-4 text-center mt25"> <a target="_blank" href="https://www.facebook.com/taesan.choi"><li class="social facebook"><i class="fa fa-facebook-square"></i></li></a> <a target="_blank" href="http://github.com/imcts"><li class="social github"><i class="fa fa-github-square"></i></li></a> <a target="_blank" href="mailto:imcts@nate.com"><li class="social email"><i class="fa fa-envelope"></i></li></a> </div> </div> </div> </footer> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script> <script src="/js/bootstrap.min.js"></script> <!-- Google Analytics Tracking code --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-83979019-1', 'auto'); ga('send', 'pageview'); </script> </body> </html>
